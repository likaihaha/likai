<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>点击烟花演示</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
      user-select: none;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <canvas id="fireCanvas"></canvas>

  <script>
    (function() {
      const canvas = document.getElementById('fireCanvas');
      const ctx = canvas.getContext('2d');

      let w = window.innerWidth;
      let h = window.innerHeight;

      // 适配设备像素比，避免模糊
      function resize() {
        const dpr = window.devicePixelRatio || 1;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function updateSize() {
        w = window.innerWidth;
        h = window.innerHeight;
        resize();
      }

      window.addEventListener('resize', updateSize);
      updateSize();

      // 粒子和火箭集合
      const rockets = [];
      const particles = [];

      // 点击时发射火箭
      canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const tx = e.clientX - rect.left;
        const ty = e.clientY - rect.top;
        const startX = w / 2;
        const startY = h - 10;
        rockets.push(new Rocket(startX, startY, tx, ty));
      });

      // 火箭对象：从起点移动到目标点
      class Rocket {
        constructor(x, y, tx, ty) {
          this.x = x;
          this.y = y;
          this.tx = tx;
          this.ty = ty;

          const dx = tx - x;
          const dy = ty - y;
          const dist = Math.hypot(dx, dy);
          // 基于距离自适应速度，保持稳定的飞行感
          const speed = Math.min(10, Math.max(4, dist / 20));
          this.vx = (dx / dist) * speed;
          this.vy = (dy / dist) * speed;

          this.radius = 2;
          this.alive = true;

          // 火箭尾部颜色（爆炸前可见）随机
          this.color = `hsl(${Math.floor(Math.random() * 360)},100%,60%)`;
          this.travelled = 0;
          this.maxTravel = dist;
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.travelled += Math.hypot(this.vx, this.vy);

          const toTarget = Math.hypot(this.tx - this.x, this.ty - this.y);
          const reached = toTarget <= Math.max(Math.abs(this.vx), Math.abs(this.vy)) + 0.5;
          if (reached || this.travelled >= this.maxTravel) {
            this.alive = false;
            explode(this.tx, this.ty);
          }
        }

        draw() {
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x - 1, this.y - 1, 2, 2);
        }
      }

      // 爆炸：在点(x, y)生成粒子
      function explode(x, y) {
        const baseHue = Math.floor(Math.random() * 360);
        const count = 60 + Math.floor(Math.random() * 60);
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 6 + 2;
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;
          const life = 60 + Math.floor(Math.random() * 40);
          particles.push(new Particle(x, y, vx, vy, baseHue, life));
        }
      }

      // 粒子对象：受重力、摩擦、淡出
      class Particle {
        constructor(x, y, vx, vy, hue, life) {
          this.x = x;
          this.y = y;
          this.vx = vx;
          this.vy = vy;
          this.hue = hue;
          this.life = life;
          this.maxLife = life;
          this.size = Math.random() * 2 + 1;
          this.friction = 0.98;
          this.gravity = 0.04;
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.vx *= this.friction;
          this.vy *= this.friction;
          this.vy += this.gravity;
          this.life--;
        }

        draw() {
          const t = this.life / this.maxLife;
          const alpha = Math.max(t, 0);
          // 粒子颜色：基色附近微调，带透明度
          ctx.fillStyle = `hsla(${(this.hue + Math.random() * 10 - 5) | 0}, 100%, 60%, ${alpha})`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
        }

        isDead() {
          return this.life <= 0;
        }
      }

      // 动画循环
      let lastTime = performance.now();
      function loop(now) {
        const dt = now - lastTime;
        lastTime = now;

        // 半透明覆盖，保留拖尾效果
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.fillRect(0, 0, w, h);

        // 更新并绘制火箭
        for (let i = rockets.length - 1; i >= 0; i--) {
          const r = rockets[i];
          r.update();
          r.draw();
          if (!r.alive) rockets.splice(i, 1);
        }

        // 更新并绘制粒子
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.update();
          p.draw();
          if (p.isDead()) particles.splice(i, 1);
        }

        requestAnimationFrame(loop);
      }

      // 启动循环
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
